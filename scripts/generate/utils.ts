import Ajv, { Schema } from "ajv";
import { parse } from "std/yaml/parse.ts";

export const updateFile = (
  filePath: string,
  fileContent: string,
  comment = true,
) => {
  const preamble = comment
    ? "# THIS FILE IS AUTOGENERATED. DO NOT EDIT IT BY HAND.\n"
    : "";
  return Deno.writeTextFile(filePath, preamble + fileContent);
};

export const updateReadme = ({
  readme,
  section,
  newContent,
}: {
  readme: string;
  section: string;
  newContent: string;
}): string => {
  const preamble =
    "<!-- the following section is auto-generated, do not edit -->";
  const startMarker = `<!-- AUTOGEN:${section.toUpperCase()} START -->`;
  const endMarker = `<!-- AUTOGEN:${section.toUpperCase()} END -->`;
  const wrapped = `${startMarker}\n${preamble}\n${newContent}\n${endMarker}`;

  if (
    !(readme.includes(startMarker) && readme.includes(endMarker))
  ) {
    throw new Error("Markers not found in README.md");
  }

  const pre = readme.split(startMarker)[0];
  const end = readme.split(endMarker)[1];
  return pre + wrapped + end;
};

/**
 * @param content A string of YAML content
 * @param schema  A JSON schema
 * @returns A promise that resolves to the parsed YAML content, verified against the schema. Rejects if the content is invalid.
 */
export const validateYaml = <T>(
  content: string,
  schema: Schema,
): Promise<T> => {
  return new Promise((resolve, reject) => {
    const ajv = new Ajv.default();
    const validate = ajv.compile<T>(schema);
    const data = parse(content);

    if (!validate(data)) return reject(validate.errors);

    return resolve(data);
  });
};
