#!/usr/bin/env -S deno run --allow-env --allow-read --allow-write --allow-net
import {
  Ajv,
  parseYaml,
  path,
  PortCategories,
  portsSchema,
  schema,
  walkSync,
} from "./deps.ts";
import {
  FAQ,
  Usage,
  Userstyle,
  UserstyleMaintainers,
  Userstyles,
} from "./types.d.ts";

const ROOT = new URL(".", import.meta.url).pathname;

type Metadata = {
  userstyles: Userstyles;
};

type PortMetadata = {
  categories: PortCategories;
};

export type MappedPort = Userstyle & {path: string};

const ajv = new Ajv();
const validate = ajv.compile<Metadata>(schema);
const validatePorts = ajv.compile<PortMetadata>(portsSchema);

const userstylesYaml = Deno.readTextFileSync(
  path.join(ROOT, "../userstyles.yml")
);
const userstylesData = parseYaml(userstylesYaml);
if (!validate(userstylesData)) {
  console.log(validate.errors);
  Deno.exit(1);
}

const portsYaml = await fetch(
  "https://raw.githubusercontent.com/catppuccin/catppuccin/main/resources/ports.yml"
);
const portsData = parseYaml(await portsYaml.text());
if (!validatePorts(portsData)) {
  console.log(validate.errors);
  Deno.exit(1);
}
const updateFile = (filePath: string, fileContent: string, comment = true) => {
  const preamble = comment
    ? "# THIS FILE IS AUTOGENERATED. DO NOT EDIT IT BY HAND.\n"
    : "";
  Deno.writeTextFileSync(filePath, preamble + fileContent);
};

const labelerPath = path.join(ROOT, "../../.github/labeler.yml");
const labelerContent = Object.entries(userstylesData.userstyles)
  .map(([key]) => `${key}: styles/${key}/**/*`)
  .join("\n");
updateFile(labelerPath, labelerContent);

const ownersPath = path.join(ROOT, "../../.github/CODEOWNERS");
const ownersContent = Object.entries(userstylesData.userstyles)
  .map(([key, style]) => {
    const maintainers = style.readme.maintainers
      .map((maintainer) => `@${maintainer.url.split("/").pop()}`)
      .join(" ");
    return `# /styles/${key} ${maintainers}`;
  })
  .join("\n#\n");
updateFile(ownersPath, ownersContent);

const usageContent = (usage?: Usage) => {
  if (!usage) return;
  return `#### Usage\n${usage}\n\n`;
};

const faqContent = (faq?: FAQ) => {
  if (!faq) return;
  return `#### ðŸ™‹ FAQ
${faq
  .map(({question, answer}) => `- Q: ${question}  \n\tA: ${answer}`)
  .join("\n")}`;
};

const maintainersContent = (maintainers: UserstyleMaintainers) => {
  return (
    "\n#### ðŸ’ Thanks to\n\n" +
    maintainers
      .map(({name, url}) => {
        return `- [${name ? name : url.split("/").pop()}](${url})`;
      })
      .join("\n")
  );
};

const badgesTemplate = `<p align="center">
	<a href="https://github.com/catppuccin/userstyles/issues?q=is%3Aissue+is+label%3A$PORT"><img src="https://img.shields.io/github/issues/catppuccin/userstyles?colorA=363a4f&colorB=f5a97f&style=for-the-badge"></a>
	<a href="https://raw.githubusercontent.com/catppuccin/userstyles/main/styles/$PORT/catppuccin.user.css"><img src="https://img.shields.io/badge/stylus-install-cba6f7?colorA=363a4f&style=for-the-badge"></a></p>`;

const previewsTemplate = `<p align="center">
  <img src="styles/$PORT/$ASSETS/catwalk.webp"/>
</p>

#### Previews
<details>
<summary>ðŸŒ» Latte</summary>
<img src="styles/$PORT/$ASSETS/latte.webp"/>
</details>
<details>
<summary>ðŸª´ FrappÃ©</summary>
<img src="styles/$PORT/$ASSETS/frappe.webp"/>
</details>
<details>
<summary>ðŸŒº Macchiato</summary>
<img src="styles/$PORT/$ASSETS/macchiato.webp"/>
</details>
<details>
<summary>ðŸŒ¿ Mocha</summary>
<img src="styles/$PORT/$ASSETS/mocha.webp"/>
</details>
`;

const previewsContent = (port: string) => {
  const dirs = Array.from(
    walkSync(path.join(ROOT, `../../styles/${port}/assets`), {
      match: [/catwalk.webp/],
    })
  ).map((dir) => dir.path.split("/").slice(0, -1).pop());
  const template = previewsTemplate.replaceAll("$PORT", port);
  let content: string;
  if (dirs.length == 1) {
    content = template.replaceAll("$ASSETS", dirs[0]);
  } else {
    content = dirs
      .sort((a, b) => (a.length < b.length ? -1 : a.length > b.length ? 1 : 0))
      .map((dir) =>
        template
          .replaceAll("$ASSETS", `assets/${dir}`)
          .replace("Previews", `Previews (${dir})`)
      )
      .join("\n<hr>\n");
  }
  return content.replace(
    "\n\n",
    `\n${badgesTemplate.replaceAll("$PORT", port)}\n\n`
  );
};

const categorized = Object.entries(userstylesData.userstyles).reduce(
  (acc, [slug, {category, ...port}]) => {
    acc[category] ||= [];
    acc[category].push({
      path: `styles/${slug}`,
      category,
      key: slug,
      ...port,
    });
    acc[category].sort((a, b) => a.name.localeCompare(b.name));
    return acc;
  },
  {} as Record<string, MappedPort[]>
);

const userstylesListData = portsData.categories
  .filter((category) => categorized[category.key] !== undefined)
  .map((category) => {
    return {
      meta: category,
      ports: categorized[category.key],
    };
  });

const userstyleContent = userstylesListData
  .map(
    (data) => `&nbsp;

<!-- -->
### ${data.meta.emoji} ${data.meta.name}
${data.ports
  .map(
    (userstyle) =>
      `<details>

<summary>

#### <a href="${userstyle.path}">${userstyle.name}</a> | <a href="${
        userstyle.readme["app-link"]
      }">(Website)</a>

</summary>
    &nbsp;${[
      previewsContent(userstyle.key),
      usageContent(userstyle.readme.usage),
      faqContent(userstyle.readme.faq),
      maintainersContent(userstyle.readme.maintainers),
    ].join("\n")}
    <br>
</details>`).join("\n")}`).join("\n");

const updateReadme = ({
  readme,
  section,
  newContent,
}: {
  readme: string;
  section: string;
  newContent: string;
}): string => {
  const preamble =
    "<!-- the following section is auto-generated, do not edit -->";
  const startMarker = `<!-- AUTOGEN:${section.toUpperCase()} START -->`;
  const endMarker = `<!-- AUTOGEN:${section.toUpperCase()} END -->`;
  const wrapped = `${startMarker}\n${preamble}\n${newContent}\n${endMarker}`;

  if (
    !(readmeContent.includes(startMarker) && readmeContent.includes(endMarker))
  ) {
    throw new Error("Markers not found in README.md");
  }

  const pre = readme.split(startMarker)[0];
  const end = readme.split(endMarker)[1];
  return pre + wrapped + end;
};

const readmePath = path.join(ROOT, "../../README.md");
let readmeContent = Deno.readTextFileSync(readmePath);
try {
  readmeContent = updateReadme({
    readme: readmeContent,
    section: "userstyles",
    newContent: userstyleContent,
  });
  updateFile(readmePath, readmeContent, false);
} catch (e) {
  console.log("Failed to update the README:", e);
}
