#!/usr/bin/env -S deno run --allow-env --allow-read --allow-write --allow-net
import { Ajv, parseYaml, path, portsSchema, schema, PortCategories } from "./deps.ts";
import { Userstyle, Userstyles } from "./types.d.ts";

// Common {{{

const root = new URL(".", import.meta.url).pathname;

type Metadata = {
  userstyles: Userstyles;
};

type PortMetadata = {
  categories: Categories;
};

const ajv = new Ajv();
const validate = ajv.compile<Metadata>(schema);
const validatePorts = ajv.compile<PortMetadata>(portsSchema);

const userstylesYaml = Deno.readTextFileSync(
  path.join(root, "../userstyles.yml"),
);
const data = parseYaml(userstylesYaml) as Metadata;

const portsYaml = await fetch(
  "https://raw.githubusercontent.com/catppuccin/catppuccin/main/resources/ports.yml",
);
const portsData = parseYaml(await portsYaml.text()) as PortMetadata;

// throw error if the YAML is invalid
if (!validate(data)) {
  console.log(validate.errors);
  Deno.exit(1);
}

if (!validatePorts(portsData)) {
  console.log(validate.errors);
  Deno.exit(1);
}

const updateFile = (filePath: string, fileContent: string, comment = true) => {
  Deno.writeTextFileSync(
    filePath,
    (comment ? "# THIS FILE IS AUTOGENERATED. DO NOT EDIT IT BY HAND.\n" : "") + fileContent,
  );
};
// }}}
// README Generation {{{

export type MappedPort = Userstyle & { html_url: string };

const categorized = Object.entries(data.userstyles).reduce(
  (acc, [slug, port]) => {
    !acc[port.category] && (acc[port.category] = []);
    acc[port.category].push({
      html_url: `styles/${slug}`,
      ...port,
    });
    acc[port.category].sort((a, b) => a.name.localeCompare(b.name));
    return acc;
  },
  {} as Record<string, MappedPort[]>,
);

const portListData = portsData.categories
  .filter((category) => categorized[category.key] !== undefined)
  .map((category) => {
    return {
      meta: category,
      ports: categorized[category.key],
    };
  });

const updateReadme = ({
  readme,
  section,
  newContent,
}: {
  readme: string;
  section: string;
  newContent: string;
}): string => {
  const preamble =
    "<!-- the following section is auto-generated, do not edit -->";
  const markers = {
    start: `<!-- AUTOGEN:${section.toUpperCase()} START -->`,
    end: `<!-- AUTOGEN:${section.toUpperCase()} END -->`,
  };

  const wrapped = markers.start + "\n" + preamble + "\n" + newContent + "\n" +
    markers.end;

  if (
    !(
      readmeContent.includes(markers.start) &&
      readmeContent.includes(markers.end)
    )
  ) {
    throw new Error("Markers not found in README.md");
  }

  const pre = readme.split(markers.start)[0];
  const end = readme.split(markers.end)[1];

  return pre + wrapped + end;
};

const readmePath = path.join(root, "../../README.md");
let readmeContent = Deno.readTextFileSync(readmePath);

const portContent = portListData
  .map((data) => {
    return `<details open>
<summary>${data.meta.emoji} ${data.meta.name}</summary>

${data.ports.map((port) => `- [${port.name}](${port.html_url})`).join("\n")}

</details>`;
  })
  .join("\n");

try {
  readmeContent = updateReadme({
    readme: readmeContent,
    section: "userstyles",
    newContent: portContent,
  });
} catch (e) {
  console.log("Failed to update the README:", e);
} finally {
  updateFile(readmePath, readmeContent, false);
}

// }}}
// Labeler {{{
const labelerPath = path.join(root, "../../.github/labeler.yml");
const labelerContent = Object.keys(data.userstyles)
  .map((key) => `${key}: styles/${key}/**/*`)
  .join("\n");

updateFile(labelerPath, labelerContent);
/// }}}
// CODEOWNERS {{{
const ownersPath = path.join(root, "../../.github/CODEOWNERS");
const ownersContent = Object.entries(data.userstyles)
  .map(
    ([key, style]) =>
      `# /styles/${key} ${
        style.readme.maintainers
          .map((maintainer) => `@${maintainer.url.split("/").pop()}`)
          .join(" ")
      }`,
  )
  .join("\n#\n");

updateFile(ownersPath, ownersContent)
/// }}}
